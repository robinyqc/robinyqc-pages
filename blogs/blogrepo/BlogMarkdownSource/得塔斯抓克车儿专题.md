# 得塔斯抓克车儿专题

https://vjudge.net/contest/677000

看不到是因为有密码，密码显然是不能公开的。看得到说明你有密码，那么我显然不用给你密码了。

## A. 市场

LOJ 6029

题意：区间加，区间除，区间求 $\min$，区间求和。

很是神秘的题目。不能用简单的暴力。因为有区间加，暴力做，暴力地势能分析（也就是将势能看作 $\sum \log a_i$）并不正确——区间加操作可以使势能加 $O(n)$。

但是一个性质（我没观察出来）：若将势能看作 $\sum \log |a_i - a_{i -1}|$，那么——

+ 区间加操作使势能增加 $O(\log n)$。
+ 区间除法操作每层递归使势能减 $1$。

因此，若用线段树较好地维护差分数组以定位需要被除法操作的位置，应该可以做出这个问题。

不过有个更好的实现。具体来说，将一个区间的势能看作其最大值减去最小值，那么——

+ 区间加操作不改变势能。
+ 区间除法操作，设操作后，$mx\gets mx', mn\gets mn'$，
  + 如果 $mx - mn = mx' - mn'$，也就是势能不变化，需要特殊处理。那么对于区间内每个数 $x (mn \leq x\leq mn)$，都有  $mx - x = mx' - x'$，也就是 $mx - mx' = x - x'$。发现这是一个区间加操作，就打个加法 tag。
  + 否则，势能发生变化，注意到这里一定减半，直接暴力递归两个子树。

复杂度是 $O(n\log^2 n)$。

## Minimax

P5298

转移方程可以看洛谷题解。这里的技巧是，线段树合并的时候可以有懒标记，在合并的过程中也可能产生懒标记。

## 众数

P8496

可以摩尔投票。具体来说，先用启发式合并或线段树合并维护每个序列的众数，然后摩尔投票出来询问序列们的绝对众数，最后再检查是否合法即可。

## Nauuo and Binary Tree

LOJ 6669

考虑先将每个点的深度问到，耗费 $n$ 次询问。然后按深度从浅到深依次确定每个点的位置。

假设当前确定了前 $i$ 层的形态。首先对前 $i$ 层树剖。若当前在确定点 $x$ 的位置，设当前定位到 $x$ 是在  $y$ 的子树中（初始时 $y = 1$），那么询问  $y$ 所在重链链底 $b$ 和 $x$ 的距离。根据 $\text{dist}(x, b) = dep_x + dep_b - 2dep_l$（$l = \text{lca}(x, b)$），可以求出 $l$ 的深度，那么由于重链每个点的深度互不相同，所以可以确定 $l$ 是哪个点。那么 $x$ 就是 $l$ 的一个轻子树内的节点。由于是二叉树，所以可以确定 $x$ 在哪个子树内，于是将 $y\gets lson_l$ 就可以了。

根据树剖的原理，总询问次数 $O(n\log n)$。

## Empty Rectangles

CF364E

二维分治题目。考虑将矩形划分成两半，先统计这两半内部的答案，最后计算跨过中轴线的合法矩形个数。

假设当前矩形大小是 $h\times h$，那么计算跨过中轴线的合法矩形个数容易做到 $O(h^2 k)$。简单来说，枚举左端点 $l$，在右端点 $r$ 向右移动的时候，合法矩形的范围是单调的，于是可以维护“当前含有 $i(0\leq i\leq k)$ 个 $1$ 的矩形个数”。

然后套上二维分治：每次选择一维的中点划分，下一次就选择另一维的。总复杂度就是 $O(n^2k\log n)$。具体分析一下：设 $T(s)$ 为矩形面积为 $s$ 的复杂度，那么每两次划分后：$T(s) = 4T(\frac s4) + O(sk)$。带入主定理得到复杂度为 $O(sk\log s)=O(nmk\log (nm))$。

## 镜子里的昆虫

P4690

数点数点全是数点！跟数点过不去了。

区间查颜色是一个喜闻乐见的二维偏序问题。设 $pre_i$ 等于最大的 $j$ 满足 $a_i = a_i \and j < i$。那么一个区间的颜色数就是 $pre_i < l (l\leq i < r)$ 的 $i$ 的个数。写成二维数点的形式就是：平面上有若干点 $(i, pre_i)$ ，每次询问一个矩形内点的个数。于是可以扫描线加树状数组做。

加上区间赋值怎么做呢？可以加上时间维，进行三维数点！因为区间赋值操作，根据 odt 理论，总共只会改变 $O(n + m)$ 次 $pre$。因此每个点存在的时间是一个连续段。因此三维数点即可。复杂度  $O(n\log^2 n)$。

## seats 排座位

P4898

致敬传奇题目万猪拱塔。

给定一个黑白染色的矩形，如何判断所有黑色块是否恰好构成一个矩形？显然可以前缀和或者直接 bfs。但是另一种做法是，一个矩形全黑，当且仅当含有奇数个黑色格子的 2x2 的子矩形恰好有 4 个。

这道题就要使用这个定理。设 $f(i)$ 表示填入 $[0, i]$ 编号的选手，含有奇数个黑色格子的 2x2 子矩形有多少个。由于若有至少一个黑色格子，满足条件的子矩形至少有 $4$ 个，所以 $f$ 的最小值的个数就是当前的答案。

并且，一个子矩形 $(a, b, c, d)$ （abcd 是指这四个格子依次出现的时间）是对 $f(a)..f(b), f(c)..f(d)$ 造成了贡献。因此每次矩形发生了变动，就是重新排列 $(a, b, c, d)$，相当于撤回两个区间加法，再加上了另两个区间加。线段树维护即可。

## Highway Buses

Gym 102394H

显然 DS 专题不能只有 DS 题的。

首先由于任意一条路径的长度都是一次函数，所以最值一定在 $T = 1$ 或者 $T = T_{max}$ 取到。因此，跑两次分别计算即可。

对于边权固定的单个问题，如何做呢？$O(n^2\log n)$ 是容易的，只需将图暴力建出然后跑 Dij。如何 $O(n^2)$ 呢？注意这个图很特殊——它每个点的出边边权是一样的。对于这种图，容易仅用二叉堆做到 $O(n\log n + m)$ 的复杂度：若一个点 $i$ 被确定是当前 $d_i + c_i$ 最小的点，那么，跟它相邻的，还不知道距离的点的最短距离就都是 $d_i + c_i$（$d$ 是他到 $1$ 的距离，$c$ 是边权），将它们入队。正确性就联想普通 Dijkstra 算法。复杂度是因为每个点只会入队一次。于是做到了 $O(n^2)$。

对于树，如何做呢？考虑点分治优化建图。在上述改进的 Dij 算法中，设当前优先队列取出的那个最近的点为 $x$，我们需要寻找它的邻居并将其入队。它出现在 $O(\log n)$ 层分治结构中。对于某一层，设它的根为 $r$，那么若 $dis(x, r) + dis(r, y) < f_x$ 的 $y$ 就是 $x$ 直连的点。那么就把 $y$ 入队。由于此时 $y$ 的距离已经确定了，那么此后它再成为入点是没用的了。所以可以将 $y$ 从这一层删掉了。所以，每层每个点只会连出一条边，总共就是 $O(n\log n)$ 条边。所以现在的复杂度就是 $O(n\log n + m) = O(n\log n)$。

对于不是树，怎么做呢？我们先拎一棵生成树出来，跑刚才的算法（先不跑 Dij，只是把图建出来）。考虑从 $i$ 到 $j$，如果经过了一条非树边 $(u, v)$，那么类似刚才的分治，建立一个以 $u$ 为根的层，点集是所有点，然后跑建图。容易发现这样便能覆盖任意 $x\to u\to y$ 的路径。最后 Dij 跑最短路出来。总复杂度 $O(n(\log n + m - n))$。

## Number of Components

CF1270H

先想想如何线性计算答案，再考虑修改。

这种顺序对/逆序对的题，都可以考虑先找到全局最小值，看看它怎么变化。比如这个题，全局最小值（假设在 $p_0$）向后面所有点连边。那么后面就是一个连通块。再往前找到 $p_0$  的前缀最小值（假设在 $p_1$），它和 $(p_1, p_0)$ 的每个点连边。如果 $[p_1, p_0)$ 存在一个点，小于 $p_0$ 的后缀最大值，那么 $p_0, p_1$ 对应的两个连通块要合并成一个连通块（其实存在的这个点如果有一定可以是 $p_1$）。以此类推……所以每个连通块都是连续下标的。

考虑什么时候连不上：这个连通块的最小值大于其后连通块的最大值。更进一步地，前缀 $\min$ 大于后缀 $\max$。那么一定存在一个值 $v$，使得存在一个前缀，每个值大于 $v$，剩下的那个后缀每个值小于等于 $v$，并且 $a$ 存在一个值等于 $v$。而连通块个数就是满足以上条件的  $v$ 的个数。不妨让大于 $v$ 的为黑色，小于等于 $v$ 的为白色，那么黑白交界处若只有一个，则  $v$ 合法，否则不合法。黑白交界处说明 $a_i < v < a_{i + 1}$ 或者  $a_i > v > a_{i + 1}$。

那么维护 $f(v)$ 表示 $v$  的黑白交界处个数。由于黑白交界处至少有一个，那么 $f$ 的最小值个数就是答案（怎么和排座位那么像），线段树维护即可。

## TATT

P3769

$\sqrt n$ 做法跑不过 $n^{\frac 23}$ 做法。

一个四维偏序题。将每个点按 $a$ 排序之后，转化为三维偏序问题。可以 3d 树直接维护，复杂度  $O(n^{5/3})$。

不好。我们使用树状数组处理 $b$ 维，用 2d 树处理 $c, d$ 维。不过为啥这样？$O(n\sqrt n \log n)$ 不是还不如树套树套树  $O(n\log^3 n)$？因为树状数组（或者线段树）套 2d 树其实是 $O(n\sqrt n)$ 的！考虑每次查询是 $\sum\sqrt {2^i}$，仔细分析就发现这是 $\sqrt n$ 的（和 KD 树二进制分组做法是一样的）。



还有一些题，不过都是板子了，我就不写了。